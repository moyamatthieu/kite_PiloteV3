# Règles de Codage

## Bonnes pratiques générales

- **Commentaires** : Toujours ajouter un commentaire descriptif pour chaque élément clé et chaque fonctions du code. Les commentaires doivent expliquer le "pourquoi" et non seulement le "quoi".

- **Bibliothèques externes** : Ne jamais modifier le code des bibliothèques externes. Si une modification est nécessaire, documentez-la et utilisez un fork.

- **Compilation** : S'assurer que le code compile sans erreurs avant de le soumettre. Utilisez des outils d'intégration continue pour vérifier automatiquement.

- **Performances** : Optimiser le code pour les performances, en particulier sur l'ESP32 qui a une puissance de calcul limitée. Évitez les boucles inutiles et les allocations dynamiques fréquentes.

- **Architecture** : Respecter l'architecture existante du projet et placer les fonctions au bon endroit. Suivez les conventions de nommage et de structure des dossiers.

- **Évolutivité** : Réfléchir en termes de développement futur pour éviter des modifications structurelles plus tard. Utilisez des interfaces et des abstractions pour faciliter les extensions.

## Architecture du projet

- **Objectif principal** : L'objectif lointain est d'arriver à ce projet : `docs-fr/projet_kite_complet.md`. Ce document décrit la vision complète du projet.

- **Architecture MCP** : Utiliser l'architecture MCP (Model-Controller-Presenter) pour structurer le code. Cela permet une séparation claire des responsabilités et facilite la maintenance.

- **Objectifs** : Suivre les objectifs définis dans le fichier `projet_kite_complet.md`. Chaque module doit contribuer à ces objectifs.

- **Mémoire SPIFFS** : Ne pas utiliser la mémoire SPIFFS pour le stockage. Préférez des alternatives comme LittleFS ou des bases de données légères.

- **Organisation** : Respecter la hiérarchie des dossiers et l'organisation logique du code. Chaque module doit rester dans son domaine de responsabilité.

- **Modularité** : Veiller à ce que chaque module soit autonome et réutilisable. Les dépendances entre modules doivent être minimisées.

## Méthodologie de travail

- **Réflexion structurée** : Adopter une réflexion organisée et structurée avant de commencer à coder. Utilisez des diagrammes et des spécifications pour planifier.

- **Auto-correction** : Corriger ses propres idées en suivant les instructions générales. Relisez votre code et testez-le avant de demander une revue.

- **Initiative** : Prendre des initiatives pertinentes pour améliorer le projet. Proposez des améliorations mais documentez-les clairement.

- **Anticipation** : Anticiper les besoins futurs lors de l'implémentation de nouvelles fonctionnalités. Pensez à l'évolutivité et à la maintenance.

- **Tests** : Écrire des tests unitaires et d'intégration pour valider le comportement du code. Utilisez des frameworks comme Google Test ou Catch2.

- **Documentation** : Documenter chaque module et chaque fonction. Utilisez des outils comme Doxygen pour générer une documentation lisible.

## Processus de revue de code

- **Revue par les pairs** : Chaque modification doit être revue par au moins un autre développeur. Utilisez des outils comme GitHub Pull Requests.

- **Critères de qualité** : Vérifiez que le code est lisible, performant, et respecte les conventions du projet.

- **Feedback constructif** : Donnez un feedback constructif et précis. Proposez des solutions aux problèmes identifiés.

- **Validation** : Assurez-vous que tous les tests passent avant d'approuver une modification.

## Gestion des versions

- c'est un projet amateur, push directement les corrections sur la branche main

## Outils recommandés

- **IDE** : Utilisez Visual Studio Code avec les extensions recommandées (PlatformIO, C/C++ IntelliSense, etc.).

- **Linting** : Configurez un linter comme `clang-tidy` ou `cppcheck` pour détecter les erreurs et les mauvaises pratiques.

- **Formatage** : Utilisez un outil de formatage comme `clang-format` pour garantir un style de code cohérent.

- **CI/CD** : Configurez une pipeline CI/CD pour automatiser les tests et les déploiements.

- **Monitoring** : Utilisez des outils comme Serial Monitor ou Logic Analyzer pour déboguer le matériel.

- **Documentation** : Utilisez des outils comme Markdown ou Doxygen pour documenter le projet.