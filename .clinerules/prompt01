- Toujours ajouter un commentaire décrivant la fonction de chaque élément clé du code.
- ne modifie jamais le code des librairies !!!!!




# Guide de Développement - Projet Kite PiloteV3

## Introduction

Bienvenue dans le projet Kite PiloteV3 ! Ce document présente les instructions et les bonnes pratiques pour travailler sur ce projet. Le projet est basé sur un ESP32 qui fournit un serveur web avec capacité de mise à jour OTA (Over The Air) et une interface utilisateur via un écran OLED.

## Structure du Projet

```
kite_PiloteV3/
├── src/                    # Code source principal
│   └── main.cpp            # Point d'entrée du programme
├── include/                # Fichiers d'en-tête
├── lib/                    # Bibliothèques spécifiques au projet
├── docs-fr/                # Documentation en français
├── platformio.ini          # Configuration PlatformIO
├── wokwi.toml              # Configuration pour simulation Wokwi
└── diagram.json            # Définition du circuit pour Wokwi
```

## Fonctionnalités Principales

- **Connectivité WiFi**: Connexion à un réseau sans fil
- **Serveur Web Asynchrone**: Interface accessible via navigateur
- **Mise à jour OTA**: Mise à jour du firmware à distance
- **Affichage OLED**: Interface visuelle locale
- **Indicateurs LED**: Retour visuel de l'état du système

## Conventions de Code

### Général

1. **Langue**: Utiliser le français pour les commentaires, les noms de variables descriptifs, et la documentation
2. **Indentation**: Utiliser 2 espaces pour l'indentation (pas de tabulations)
3. **Nommage**:
   - Variables: `camelCase` (ex: `ledState`, `derniereMiseAJour`)
   - Constantes: `SNAKE_CASE_MAJUSCULES` (ex: `LED_PIN`, `SCREEN_WIDTH`)
   - Fonctions: `camelCase` avec verbe d'action (ex: `initialiserWiFi()`, `gererRequeteWeb()`)
   - Classes: `PascalCase` (ex: `GestionnaireOTA`, `AffichageOLED`)

### Style de Code

```cpp
// Exemple de style de fonction
void initialiserEcranOLED() {
  // Un commentaire explicatif sur ce que fait cette fonction
  if (!display.begin(SSD1306_SWITCHCAPVCC, SCREEN_ADDRESS)) {
    Serial.println(F("Échec d'allocation SSD1306"));
    for (;;); // Ne pas continuer, boucle infinie
  }
  
  display.clearDisplay();
  display.setTextSize(1);
  display.setTextColor(SSD1306_WHITE);
}

// Exemple de style pour structure conditionnelle
if (etatConnexion == CONNECTE) {
  allumerLED();
} else {
  clignoterLED();
}
```

## Principes de Développement

### 1. Code Moderne et Explicite

- Préférer les fonctions et variables avec des noms descriptifs
- Utiliser les nouvelles fonctionnalités du C++ moderne quand c'est approprié
- Documenter le "pourquoi" plutôt que le "comment" dans les commentaires
- Diviser le code en petites fonctions avec une responsabilité unique

```cpp
// À éviter
void f1() {
  int a = 100;
  if (a > 50) { /* ... */ }
}

// Préférer
void verifierEtatBatterie() {
  int niveauBatterie = lireNiveauBatterie();
  if (niveauBatterie > SEUIL_BATTERIE_FAIBLE) {
    afficherEtatBatterie(niveauBatterie);
  } else {
    declencherAlerteBatterieFaible();
  }
}
```

### 2. Programmation Asynchrone

- Éviter les `delay()` qui bloquent l'exécution
- Utiliser `millis()` pour la gestion du temps non-bloquante
- Favoriser les callbacks et les gestionnaires d'événements

```cpp
// Éviter ceci
void loop() {
  allumerLED();
  delay(1000);
  eteindreLED();
  delay(1000);
}

// Préférer cette approche
unsigned long dernierChangementLED = 0;
bool etatLED = false;
const unsigned long INTERVALLE_CLIGNOTEMENT = 1000;

void loop() {
  unsigned long maintenant = millis();
  
  if (maintenant - dernierChangementLED > INTERVALLE_CLIGNOTEMENT) {
    dernierChangementLED = maintenant;
    etatLED = !etatLED;
    digitalWrite(LED_PIN, etatLED ? HIGH : LOW);
  }
  
  // Autres tâches peuvent s'exécuter pendant ce temps
  verifierCapteurs();
  actualiserAffichage();
}
```

### 3. Code Robuste et Redondant

- Valider toutes les entrées et gérer les cas d'erreur
- Implémenter des mécanismes de récupération (watchdog, redémarrage)
- Journaliser les événements importants et les erreurs
- Ajouter des vérifications de santé périodiques

```cpp
// Exemple de gestion d'erreur robuste
bool connecterWiFi(const char* ssid, const char* motDePasse) {
  int tentatives = 0;
  const int MAX_TENTATIVES = 3;
  
  while (tentatives < MAX_TENTATIVES) {
    Serial.printf("Tentative de connexion WiFi %d/%d...\n", tentatives + 1, MAX_TENTATIVES);
    
    WiFi.begin(ssid, motDePasse);
    
    // Attente avec timeout
    unsigned long debut = millis();
    while (WiFi.status() != WL_CONNECTED && millis() - debut < 10000) {
      delay(500);
      Serial.print(".");
    }
    
    if (WiFi.status() == WL_CONNECTED) {
      Serial.println("\nConnecté au réseau WiFi!");
      return true;
    }
    
    tentatives++;
    Serial.println("\nÉchec de connexion, nouvelle tentative...");
  }
  
  Serial.println("Impossible de se connecter au WiFi après plusieurs tentatives");
  return false;
}
```

### 4. Programmation Multitâche

- Diviser le code en tâches indépendantes avec des responsabilités claires
- Utiliser des variables d'état pour suivre la progression des différentes tâches
- Pour les fonctionnalités complexes, envisager d'utiliser FreeRTOS

```cpp
// Structure pour la gestion de tâches multiples
void loop() {
  unsigned long tempsActuel = millis();
  
  // Tâche 1: Gérer l'affichage OLED (toutes les 250ms)
  if (tempsActuel - derniereMiseAJourAffichage > 250) {
    derniereMiseAJourAffichage = tempsActuel;
    actualiserAffichage();
  }
  
  // Tâche 2: Vérifier la connexion WiFi (toutes les 30 secondes)
  if (tempsActuel - dernierVerificationWiFi > 30000) {
    dernierVerificationWiFi = tempsActuel;
    verifierConnexionWiFi();
  }
  
  // Tâche 3: Gérer les requêtes OTA (continu, géré par les callbacks)
  ElegantOTA.loop();
  
  // Tâche 4: Mettre à jour les capteurs (toutes les 5 secondes)
  if (tempsActuel - derniereLectureCapteurs > 5000) {
    derniereLectureCapteurs = tempsActuel;
    lireCapteurs();
  }
}
```

## Guide Pratique pour Débutants

### Premier Pas: Comprendre le Code Existant

1. Commencez par lire le fichier `main.cpp` pour comprendre le flux principal
2. Identifiez les principales fonctions et leur rôle
3. Examinez le fichier `platformio.ini` pour comprendre les dépendances

### Modification du Code

1. **Petits changements**:
   - Commencez par des modifications simples (textes, délais, paramètres)
   - Testez régulièrement sur le simulateur Wokwi avant de flasher le matériel

2. **Ajout de fonctionnalités**:
   - Créez une fonction séparée pour votre nouvelle fonctionnalité
   - Intégrez-la dans le cycle principal (`loop()`) en respectant l'approche asynchrone
   - Documentez votre code avec des commentaires explicatifs

### Bonnes Pratiques pour Débuter

- **Sauvegardez régulièrement** votre code et créez des points de restauration
- **Testez par étapes**: validez chaque petite modification avant de continuer
- **Documentez vos changements**: notez ce que vous avez modifié et pourquoi
- **Ne craignez pas de demander de l'aide**: la communauté est là pour vous aider

## Développement et Test

### Environnement de Développement

- **PlatformIO**: Utilisé pour la compilation et le déploiement
- **Wokwi**: Simulateur pour tester le code sans matériel physique

### Processus de Test

1. **Simulation**: Tester d'abord sur Wokwi
2. **Déploiement local**: Flasher sur l'ESP32 via USB
3. **Mise à jour OTA**: Une fois la première version installée, utiliser OTA pour les mises à jour

## Ressources

- [Documentation ESP32](https://docs.espressif.com/projects/esp-idf/en/latest/)
- [Tutoriels AsyncWebServer](https://randomnerdtutorials.com/esp32-async-web-server-espasyncwebserver-library/)
- [Guide ElegantOTA](https://github.com/ayushsharma82/ElegantOTA)
- [Tutoriels Adafruit SSD1306](https://learn.adafruit.com/monochrome-oled-breakouts)

---

## Instructions pour Cline - Assistant IA

Ce projet utilise Cline, un assistant IA de programmation, pour faciliter le développement et le débogage. Voici les instructions spécifiques pour mieux utiliser Cline avec ce projet.

### Contexte et Connaissances Requises

Cline devrait être familier avec:

- **ESP32**: Architecture, caractéristiques, limitations et fonctionnalités principales
- **Développement IoT**: Principes de conception pour appareils contraints en ressources
- **PlatformIO**: Configuration, compilation et déploiement de projets
- **Programmation C++ pour microcontrôleurs**: Styles et bonnes pratiques spécifiques à l'IoT
- **Serveurs Web sur ESP32**: Utilisation d'ESPAsyncWebServer et concepts associés
- **Mise à jour OTA (ElegantOTA)**: Principes de fonctionnement et implémentation
- **Affichages OLED avec la bibliothèque Adafruit SSD1306**: Commandes et patterns courants

### Tâches Assistées par Cline

Cline peut aider avec:

1. **Débogage de code**: Identifier les erreurs et proposer des solutions
2. **Optimisation du code**: Suggérer des améliorations pour réduire la consommation de mémoire et améliorer les performances
3. **Implémentation de nouvelles fonctionnalités**: Aider à concevoir et coder de nouvelles fonctions
4. **Refactorisation**: Proposer des structures plus claires et maintenables pour le code existant
5. **Documentation**: Générer ou améliorer les commentaires et la documentation du projet
6. **Aide à la simulation et au débogage**: Conseiller sur l'utilisation de Wokwi et d'autres outils

### Comment Interroger Cline

Pour des résultats optimaux avec Cline sur ce projet:

1. **Spécifiez le contexte**:
   ```
   [Contexte: OTA pour ESP32] Comment puis-je implémenter une barre de progression pendant la mise à jour?
   ```

2. **Incluez des segments de code pertinents** si vous posez une question sur un code existant

3. **Mentionnez les contraintes techniques**:
   ```
   [Contraintes: ESP32 avec 4MB de flash et écran OLED 128x64] Comment optimiser l'affichage des données de capteurs?
   ```

4. **Précisez l'intention et l'objectif**:
   ```
   Je veux ajouter une fonctionnalité pour sauvegarder des paramètres en EEPROM. L'objectif est de conserver ces réglages après un redémarrage.
   ```

### Convention pour les Demandes de Code

Utilisez ce format pour demander à Cline ou GitHub Copilot d'écrire du code:

```
[Demande de code]
Fonctionnalité: [description brève]
Entrées: [paramètres attendus]
Sorties: [résultats attendus]
Contraintes: [limites techniques ou exigences spécifiques]
Style: [respecter les conventions du projet]
```

### Exemple d'Interaction avec Cline ou GitHub Copilot

```
[Demande de code]
Fonctionnalité: Fonction pour afficher un message centré sur l'écran OLED
Entrées: Texte à afficher (String), taille de police (int)
Sorties: Affichage du texte centré horizontalement sur l'écran
Contraintes: Compatible avec l'objet display déclaré dans main.cpp
Style: Suivre les conventions camelCase et utiliser une approche non-bloquante
```

---

## Instructions pour les Assistants IA (Cline et GitHub Copilot)

Ce projet utilise des assistants IA de programmation (Cline et GitHub Copilot) pour faciliter le développement et le débogage. Voici les instructions spécifiques pour mieux utiliser ces outils avec ce projet.

### Contexte et Connaissances Requises

Les assistants IA devraient être familiers avec:

- **ESP32**: Architecture, caractéristiques, limitations et fonctionnalités principales
- **Développement IoT**: Principes de conception pour appareils contraints en ressources
- **PlatformIO**: Configuration, compilation et déploiement de projets
- **Programmation C++ pour microcontrôleurs**: Styles et bonnes pratiques spécifiques à l'IoT
- **Serveurs Web sur ESP32**: Utilisation d'ESPAsyncWebServer et concepts associés
- **Mise à jour OTA (ElegantOTA)**: Principes de fonctionnement et implémentation
- **Affichages OLED avec la bibliothèque Adafruit SSD1306**: Commandes et patterns courants
